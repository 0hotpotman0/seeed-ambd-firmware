/*
 * Generated by erpcgen 1.7.4 on Tue Aug 18 10:43:04 2020.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#include "erpc_port.h"
#include "erpc_codec.h"
extern "C"
{
#include "rpc_ble_api.h"
// import callbacks declaration from other groups
}

#if 10704 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;

//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);


// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    codec->writeBinary(data->dataLength, data->data);
}


//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);


// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if (data->data == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}



// host interface _Ble_HostInitialize function client shim.
uint8_t _Ble_HostInitialize(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, khost_service_id, khost__Ble_HostInitialize_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, khost__Ble_HostInitialize_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gap_le interface rpc_le_gap_init function client shim.
bool rpc_le_gap_init(uint8_t link_num)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gap_init_id, request.getSequence());

        codec->write(link_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_gap_init_id);

    if (err)
    {
        return false;
    }

    return result;
}

// rpc_gap_le interface rpc_le_gap_msg_info_way function client shim.
void rpc_le_gap_msg_info_way(bool use_msg)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gap_msg_info_way_id, request.getSequence());

        codec->write(use_msg);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_gap_msg_info_way_id);

    return;
}

// rpc_gap_le interface rpc_le_get_max_link_num function client shim.
uint8_t rpc_le_get_max_link_num(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_get_max_link_num_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_get_max_link_num_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// rpc_gap_le interface rpc_le_set_gap_param function client shim.
RPC_T_GAP_CAUSE rpc_le_set_gap_param(RPC_T_GAP_LE_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_gap_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_set_gap_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_get_gap_param function client shim.
RPC_T_GAP_CAUSE rpc_le_get_gap_param(RPC_T_GAP_LE_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_get_gap_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_get_gap_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_modify_white_list function client shim.
RPC_T_GAP_CAUSE rpc_modify_white_list(RPC_T_GAP_WHITE_LIST_OP operation, const binary_t * bd_addr, RPC_T_GAP_REMOTE_ADDR_TYPE bd_type)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_modify_white_list_id, request.getSequence());

        codec->write(static_cast<int32_t>(operation));

        write_binary_t_struct(codec, bd_addr);

        codec->write(static_cast<int32_t>(bd_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_modify_white_list_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_gen_rand_addr function client shim.
RPC_T_GAP_CAUSE rpc_le_gen_rand_addr(RPC_T_GAP_RAND_ADDR_TYPE rand_addr_type, binary_t * random_bd)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_gen_rand_addr_id, request.getSequence());

        codec->write(static_cast<int32_t>(rand_addr_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, random_bd);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_gen_rand_addr_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_set_rand_addr function client shim.
RPC_T_GAP_CAUSE rpc_le_set_rand_addr(const binary_t * random_bd)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_rand_addr_id, request.getSequence());

        write_binary_t_struct(codec, random_bd);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_set_rand_addr_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_cfg_local_identity_address function client shim.
RPC_T_GAP_CAUSE rpc_le_cfg_local_identity_address(const binary_t * addr, RPC_T_GAP_IDENT_ADDR_TYPE ident_addr_type)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_cfg_local_identity_address_id, request.getSequence());

        write_binary_t_struct(codec, addr);

        codec->write(static_cast<int32_t>(ident_addr_type));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_cfg_local_identity_address_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_set_host_chann_classif function client shim.
RPC_T_GAP_CAUSE rpc_le_set_host_chann_classif(const binary_t * p_channel_map)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_set_host_chann_classif_id, request.getSequence());

        write_binary_t_struct(codec, p_channel_map);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_set_host_chann_classif_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_le interface rpc_le_write_default_data_len function client shim.
RPC_T_GAP_CAUSE rpc_le_write_default_data_len(uint16_t tx_octets, uint16_t tx_time)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_le_service_id, krpc_gap_le_rpc_le_write_default_data_len_id, request.getSequence());

        codec->write(tx_octets);

        codec->write(tx_time);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_le_rpc_le_write_default_data_len_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_config interface rpc_gap_config_cccd_not_check function client shim.
void rpc_gap_config_cccd_not_check(RPC_T_GAP_CONFIG_GATT_CCCD_NOT_CHECK cccd_not_check_flag)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_cccd_not_check_id, request.getSequence());

        codec->write(static_cast<int32_t>(cccd_not_check_flag));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_cccd_not_check_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_ccc_bits_count function client shim.
void rpc_gap_config_ccc_bits_count(uint8_t gatt_server_ccc_bits_count, uint8_t gatt_storage_ccc_bits_count)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_ccc_bits_count_id, request.getSequence());

        codec->write(gatt_server_ccc_bits_count);

        codec->write(gatt_storage_ccc_bits_count);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_ccc_bits_count_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_attribute_table_count function client shim.
void rpc_gap_config_max_attribute_table_count(uint8_t gatt_max_attribute_table_count)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_attribute_table_count_id, request.getSequence());

        codec->write(gatt_max_attribute_table_count);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_attribute_table_count_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_mtu_size function client shim.
void rpc_gap_config_max_mtu_size(uint16_t att_max_mtu_size)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_mtu_size_id, request.getSequence());

        codec->write(att_max_mtu_size);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_mtu_size_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_bte_pool_size function client shim.
void rpc_gap_config_bte_pool_size(uint8_t bte_pool_size)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_bte_pool_size_id, request.getSequence());

        codec->write(bte_pool_size);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_bte_pool_size_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_bt_report_buf_num function client shim.
void rpc_gap_config_bt_report_buf_num(uint8_t bt_report_buf_num)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_bt_report_buf_num_id, request.getSequence());

        codec->write(bt_report_buf_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_bt_report_buf_num_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_le_key_storage_flag function client shim.
void rpc_gap_config_le_key_storage_flag(uint16_t le_key_storage_flag)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_le_key_storage_flag_id, request.getSequence());

        codec->write(le_key_storage_flag);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_le_key_storage_flag_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_le_paired_device function client shim.
void rpc_gap_config_max_le_paired_device(uint8_t max_le_paired_device)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_le_paired_device_id, request.getSequence());

        codec->write(max_le_paired_device);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_le_paired_device_id);

    return;
}

// rpc_gap_config interface rpc_gap_config_max_le_link_num function client shim.
void rpc_gap_config_max_le_link_num(uint8_t le_link_num)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_config_service_id, krpc_gap_config_rpc_gap_config_max_le_link_num_id, request.getSequence());

        codec->write(le_link_num);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_config_rpc_gap_config_max_le_link_num_id);

    return;
}

// rpc_gap_adv interface rpc_le_adv_set_param function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_set_param(RPC_T_LE_ADV_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_set_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_set_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_get_param function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_get_param(RPC_T_LE_ADV_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_get_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_get_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_start function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_start(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_start_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_start_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_stop function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_stop(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_stop_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_stop_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_adv interface rpc_le_adv_update_param function client shim.
RPC_T_GAP_CAUSE rpc_le_adv_update_param(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_adv_service_id, krpc_gap_adv_rpc_le_adv_update_param_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_adv_rpc_le_adv_update_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_set_param function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_set_param(RPC_T_LE_SCAN_PARAM_TYPE param, const binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_set_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        write_binary_t_struct(codec, value);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_set_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_get_param function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_get_param(RPC_T_LE_SCAN_PARAM_TYPE param, binary_t * value)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_get_param_id, request.getSequence());

        codec->write(static_cast<int32_t>(param));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_binary_t_struct(codec, value);

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_get_param_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_start function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_start(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_start_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_start_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}

// rpc_gap_scan interface rpc_le_scan_stop function client shim.
RPC_T_GAP_CAUSE rpc_le_scan_stop(void)
{
    erpc_status_t err = kErpcStatus_Success;

    RPC_T_GAP_CAUSE result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, krpc_gap_scan_service_id, krpc_gap_scan_rpc_le_scan_stop_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<RPC_T_GAP_CAUSE>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, krpc_gap_scan_rpc_le_scan_stop_id);

    if (err)
    {
        return (RPC_T_GAP_CAUSE) -1;
    }

    return result;
}
